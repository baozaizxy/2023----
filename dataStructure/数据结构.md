# 数据结构

## 时间复杂度

**原则**

1. 如果运行时间是常数量级，用常数1表示；
2. 只保留时间函数中的最高阶项；
3. 如果最高阶项存在，则省去最高阶项前面的系数。

###### T（N）=log N

```c
void eat2(int n){
   for(int i=1; i<n; i*=2){
       System.out.println("角标2咋没了");
   }
}
```

###### T( N )= 0.5 n^2 + 0.5 n

```c
void eat4(int n){
   for(int i=0; i<n; i++){
       for(int j=0; j<i; j++){
           System.out.println("0.5哪来的 看如下解释");
       }
       System.out.println("无所谓 渐进复杂度不要系数");
   }
}
```

对于外循环，其时间复杂度为 O(n)；

对于内循环环，当 i=0 时，内循环执行了 n 次，当 i=1 时，执行了 n-1 次，······当 i=n-1 时，执行了 1 次。

因此内循环总的执行次数为：

n + (n-1) + (n-2) + ... + 1 = (n^2+n)/2


根据大 O 阶推导方法，最终上述代码的时间复杂度为 ：O（ n^2）

### 渐进时间复杂度

若存在函数 f（n），使得当n趋近于无穷大时，T（n）/ f（n）的极限值为不等于零的常数，则称 f（n）是T（n）的同数量级函数。

记作 T（n）= O（f（n）），称O（f（n）） 为算法的渐进时间复杂度，简称时间复杂度。

渐进时间复杂度用大写O来表示，所以也被称为大O表示法。

**原则**

1. 如果运行时间是常数量级，用常数1表示；
2. 只保留时间函数中的最高阶项；
3. 如果最高阶项存在，则省去最高阶项前面的系数。

**O（1）< O（log n）< O（n）< O（n^2）< O( n^3) < O(2^n) < O(n!) < O(n^n)**

## 空间复杂度

递归算法的**空间复杂度=递归深度N\*每次递归所要的辅助空间**

###### O(n)

```c
 
def fun(n):
    k = 10
    if n == k:
        return n
    else:
        return fun(++n)
递归实现，调用fun函数，每次都创建1个变量k。调用n次，空间复杂度O（n*1）=O（n)。
```

###### O(1)

对于**单线程**来说，**递归有运行时堆栈**，求的是递归**最深的那一次压栈所耗费的空间的个数**

 **因为**递归最深的那一次所耗费的空间足以容纳它所有递归过程

```C
temp=0;
for(i=0;i<n;i++):
    temp = i
 
变量的内存分配发生在定义的时候，因为temp的定义是循环里边，所以是n*O(1)
temp定义在循环外边，所以是1*O(1) 
```

一般情况下，一个程序在机器上执行时：

除了需要存储程序本身的指令，常数，变量和输入数据外

还需要存储对数据操作的存储单元的辅助空间

若输入数据所占空间只取决于问题本身，和算法无关

这样就只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O（1）

![img](https://img-blog.csdnimg.cn/2020021017373073.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdTE3MjM0MDUw,size_16,color_FFFFFF,t_70)

## 线性表

| 线性表       |              |          |          |          |
| ------------ | ------------ | -------- | -------- | -------- |
| 顺序存储结构 | 链式存储结构 |          |          |          |
|              | 单链表       | 静态链表 | 循环链表 | 双向链表 |

顺序存储结构的存取操作时间为O（1）

​		 	插入和删除的操作时间为O（n）(因为要移动其他元素)

链表由数据域和指针域组成

数据域：存储真实数据

指针域：存储下一个节点的地址（指针）

（1）**头指针**

​	一般把**链表**中的第一个结点称为 头指针，其存储链表的第一个数据元素

（2）**头结点**

​	为了能更加方便地对链表进行操作，会在单链表的第一个结点（即头指针）前附设一个结点，称为 头结点

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjIyOTk3LTM2OGYzODM1MWM1ZmE3YjEucG5n?x-oss-process=image/format,png)

单链表存储结构的存取操作时间为O（n）

​		 		插入和删除的操作时间为O（n）(第一次找位置，后续只需要移动指针)

对于插入或删除数据越频繁的操作，单链表的效率就越明显

单链表判断条件            p->next = NULL

循环链表判断条件		p->next = head

**双向链表**（double linked list）：在单链表的每个结点中，再设置一个指向其前驱结点的指针域 

## 栈与队列

